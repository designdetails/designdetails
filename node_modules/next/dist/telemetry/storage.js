"use strict";exports.__esModule=true;exports.computeHash=computeHash;exports.setTelemetryEnabled=setTelemetryEnabled;exports.isTelemetryEnabled=isTelemetryEnabled;exports.record=record;var _chalk=_interopRequireDefault(require("chalk"));var _conf=_interopRequireDefault(require("conf"));var _crypto=require("crypto");var _findUp=_interopRequireDefault(require("find-up"));var _isDocker=_interopRequireDefault(require("is-docker"));var _path=_interopRequireDefault(require("path"));var _anonymousMeta=require("./anonymous-meta");var ciEnvironment=_interopRequireWildcard(require("./ci-info"));var _postPayload2=require("./post-payload");var _projectId=require("./project-id");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}}newObj.default=obj;return newObj;}}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}let config;let projectId;let randomRunId;// This is the key that stores whether or not telemetry is enabled or disabled.
const TELEMETRY_KEY_ENABLED='telemetry.enabled';// This is the key that specifies when the user was informed about anonymous
// telemetry collection.
const TELEMETRY_KEY_NOTIFY_DATE='telemetry.notifiedAt';// This is a quasi-persistent identifier used to dedupe recurring events. It's
// generated from random data and completely anonymous.
const TELEMETRY_KEY_ID=`telemetry.anonymousId`;// This is the cryptographic salt that is included within every hashed value.
// This salt value is never sent to us, ensuring privacy and the one-way nature
// of the hash (prevents dictionary lookups of pre-computed hashes).
// See the `computeHash` function.
const TELEMETRY_KEY_SALT=`telemetry.salt`;const{NEXT_TELEMETRY_DISABLED,NEXT_TELEMETRY_DEBUG}=process.env;let isDisabled=!!NEXT_TELEMETRY_DISABLED;function notify(){// No notification needed if telemetry is not enabled
if(!config||isDisabled){return;}// The end-user has already been notified about our telemetry integration. We
// don't need to constantly annoy them about it.
// We will re-inform users about the telemetry if significant changes are
// ever made.
if(config.get(TELEMETRY_KEY_NOTIFY_DATE,'')){return;}config.set(TELEMETRY_KEY_NOTIFY_DATE,Date.now().toString());console.log(`${_chalk.default.magenta.bold('Attention')}: Next.js now collects completely anonymous telemetry regarding usage.`);console.log(`This information is used to shape Next.js' roadmap and prioritize features.`);console.log(`You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`);console.log(_chalk.default.cyan('https://nextjs.org/telemetry'));console.log();}function setup(){if(config){return;}let cwd=ciEnvironment.isCI||(0,_isDocker.default)()?// CI environments will normally cache `node_modules/`
_findUp.default.sync('node_modules'):undefined;if(cwd)cwd=_path.default.join(cwd,'.next');config=new _conf.default({projectName:'nextjs',cwd});let anonymousId=config.get(TELEMETRY_KEY_ID);if(!anonymousId){config.set(TELEMETRY_KEY_ID,anonymousId=(0,_crypto.randomBytes)(32).toString('hex'));}if(!config.get(TELEMETRY_KEY_SALT)){config.set(TELEMETRY_KEY_SALT,(0,_crypto.randomBytes)(16).toString('hex'));}projectId=(0,_projectId.getProjectId)();randomRunId=(0,_crypto.randomBytes)(8).toString('hex');if(config.get(TELEMETRY_KEY_ENABLED,true)===false){isDisabled=true;}notify();}function computeHash(payload){setup();const salt=config.get(TELEMETRY_KEY_SALT);if(!salt){return null;}const hash=(0,_crypto.createHash)('sha256');// Always prepend the payload value with salt. This ensures the hash is truly
// one-way.
hash.update(salt);// Update is an append operation, not a replacement. The salt from the prior
// update is still present!
hash.update(payload);return hash.digest('hex');}function setTelemetryEnabled(_enabled){setup();const enabled=!!_enabled;config.set(TELEMETRY_KEY_ENABLED,enabled);isDisabled=!enabled;}function isTelemetryEnabled(){setup();return config.get(TELEMETRY_KEY_ENABLED,true)!==false;}function _record(_events){let events;if(Array.isArray(_events)){events=_events;}else{events=[_events];}if(events.length<1){return Promise.resolve();}setup();if(NEXT_TELEMETRY_DEBUG){// Print to standard error to simplify selecting the output
events.forEach(({eventName,payload})=>console.error(`[telemetry] `+JSON.stringify({eventName,payload},null,2)));// Do not send the telemetry data if debugging. Users may use this feature
// to preview what data would be sent.
return Promise.resolve();}// Skip recording telemetry if the feature is disabled
if(isDisabled){return Promise.resolve();}const anonymousId=config.get(TELEMETRY_KEY_ID);if(!anonymousId){return Promise.resolve();}const context={anonymousId:anonymousId,projectId:projectId,sessionId:randomRunId};const meta=(0,_anonymousMeta.getAnonymousMeta)();return(0,_postPayload2._postPayload)(`https://telemetry.nextjs.org/api/v1/record`,{context,meta,events:events.map(({eventName,payload})=>({eventName,fields:payload}))});}function record(_events){// pseudo try-catch
async function wrapper(){return await _record(_events);}return wrapper().then(value=>({isFulfilled:true,isRejected:false,value})).catch(reason=>({isFulfilled:false,isRejected:true,reason}));}
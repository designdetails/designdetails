"use strict";exports.__esModule=true;exports.default=void 0;var _nextServer=_interopRequireDefault(require("../next-server/server/next-server"));var _path=require("path");var _util=require("util");var _hotReloader=_interopRequireDefault(require("./hot-reloader"));var _router=require("../next-server/server/router");var _constants=require("../next-server/lib/constants");var _errorDebug=_interopRequireDefault(require("./error-debug"));var _amphtmlValidator=_interopRequireDefault(require("amphtml-validator"));var _index=require("../build/output/index");var Log=_interopRequireWildcard(require("../build/output/log"));var _verifyTypeScriptSetup=require("../lib/verifyTypeScriptSetup");var _watchpack=_interopRequireDefault(require("watchpack"));var _events=require("../telemetry/events");var _fs=_interopRequireDefault(require("fs"));var _utils=require("../next-server/lib/router/utils");var _react=_interopRequireDefault(require("react"));var _findPageFile=require("./lib/find-page-file");var _normalizePagePath=require("../next-server/server/normalize-page-path");var _constants2=require("../lib/constants");var _findPagesDir=require("../lib/find-pages-dir");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}}newObj.default=obj;return newObj;}}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}if(typeof _react.default.Suspense==='undefined'){throw new Error(`The version of React you are using is lower than the minimum required version needed for Next.js. Please upgrade "react" and "react-dom": "npm install --save react react-dom" https://err.sh/zeit/next.js/invalid-react-version`);}const fsStat=(0,_util.promisify)(_fs.default.stat);class DevServer extends _nextServer.default{constructor(options){super({...options,dev:true});this.renderOpts.dev=true;this.renderOpts.ErrorDebug=_errorDebug.default;this.devReady=new Promise(resolve=>{this.setDevReady=resolve;});this.renderOpts.ampValidator=(html,pathname)=>{return _amphtmlValidator.default.getInstance().then(validator=>{const result=validator.validateString(html);(0,_index.ampValidation)(pathname,result.errors.filter(e=>e.severity==='ERROR').filter(e=>this._filterAmpDevelopmentScript(html,e)),result.errors.filter(e=>e.severity!=='ERROR'));});};this.pagesDir=(0,_findPagesDir.findPagesDir)(this.dir);}currentPhase(){return _constants.PHASE_DEVELOPMENT_SERVER;}readBuildId(){return'development';}async addExportPathMapRoutes(){// Makes `next export` exportPathMap work in development mode.
// So that the user doesn't have to define a custom server reading the exportPathMap
if(this.nextConfig.exportPathMap){console.log('Defining routes from exportPathMap');const exportPathMap=await this.nextConfig.exportPathMap({},{dev:true,dir:this.dir,outDir:null,distDir:this.distDir,buildId:this.buildId});// In development we can't give a default path mapping
for(const path in exportPathMap){const{page,query={}}=exportPathMap[path];// We use unshift so that we're sure the routes is defined before Next's default routes
this.router.add({match:(0,_router.route)(path),fn:async(req,res,params,parsedUrl)=>{const{query:urlQuery}=parsedUrl;Object.keys(urlQuery).filter(key=>query[key]===undefined).forEach(key=>console.warn(`Url '${path}' defines a query parameter '${key}' that is missing in exportPathMap`));const mergedQuery={...urlQuery,...query};await this.render(req,res,page,mergedQuery,parsedUrl);}});}}}async startWatcher(){if(this.webpackWatcher){return;}let resolved=false;return new Promise(resolve=>{const pagesDir=this.pagesDir;// Watchpack doesn't emit an event for an empty directory
_fs.default.readdir(pagesDir,(_,files)=>{if(files&&files.length){return;}if(!resolved){resolve();resolved=true;}});let wp=this.webpackWatcher=new _watchpack.default();wp.watch([],[pagesDir],0);wp.on('aggregated',()=>{const dynamicRoutedPages=[];const knownFiles=wp.getTimeInfoEntries();for(const[fileName,{accuracy}]of knownFiles){if(accuracy===undefined){continue;}let pageName='/'+(0,_path.relative)(pagesDir,fileName).replace(/\\+/g,'/');pageName=pageName.replace(new RegExp(`\\.+(?:${this.nextConfig.pageExtensions.join('|')})$`),'');pageName=pageName.replace(/\/index$/,'')||'/';if(!(0,_utils.isDynamicRoute)(pageName)){continue;}dynamicRoutedPages.push(pageName);}this.dynamicRoutes=(0,_utils.getSortedRoutes)(dynamicRoutedPages).map(page=>({page,match:(0,_utils.getRouteMatcher)((0,_utils.getRouteRegex)(page))}));if(!resolved){resolve();resolved=true;}});});}async stopWatcher(){if(!this.webpackWatcher){return;}this.webpackWatcher.close();this.webpackWatcher=null;}async prepare(){await(0,_verifyTypeScriptSetup.verifyTypeScriptSetup)(this.dir,this.pagesDir);this.hotReloader=new _hotReloader.default(this.dir,{pagesDir:this.pagesDir,config:this.nextConfig,buildId:this.buildId});await super.prepare();await this.addExportPathMapRoutes();await this.hotReloader.start();await this.startWatcher();this.setDevReady();(0,_events.recordVersion)({cliCommand:'dev'});}async close(){await this.stopWatcher();if(this.hotReloader){await this.hotReloader.stop();}}async run(req,res,parsedUrl){await this.devReady;const{pathname}=parsedUrl;if(pathname.startsWith('/_next')){try{await fsStat((0,_path.join)(this.publicDir,'_next'));throw new Error(_constants2.PUBLIC_DIR_MIDDLEWARE_CONFLICT);}catch(err){}}// check for a public file, throwing error if there's a
// conflicting page
if(this.nextConfig.experimental.publicDirectory){if(await this.hasPublicFile(pathname)){const pageFile=await(0,_findPageFile.findPageFile)(this.pagesDir,(0,_normalizePagePath.normalizePagePath)(pathname),this.nextConfig.pageExtensions);if(pageFile){const err=new Error(`A conflicting public file and page file was found for path ${pathname} https://err.sh/zeit/next.js/conflicting-public-file-page`);res.statusCode=500;return this.renderError(err,req,res,pathname,{});}return this.servePublic(req,res,pathname);}}const{finished}=await this.hotReloader.run(req,res,parsedUrl);if(finished){return;}return super.run(req,res,parsedUrl);}generateRoutes(){const routes=super.generateRoutes();// In development we expose all compiled files for react-error-overlay's line show feature
// We use unshift so that we're sure the routes is defined before Next's default routes
routes.unshift({match:(0,_router.route)('/_next/development/:path*'),fn:async(req,res,params)=>{const p=(0,_path.join)(this.distDir,...(params.path||[]));await this.serveStatic(req,res,p);}});return routes;}// In development public files are not added to the router but handled as a fallback instead
generatePublicRoutes(){return[];}// In development dynamic routes cannot be known ahead of time
getDynamicRoutes(){return[];}_filterAmpDevelopmentScript(html,event){if(event.code!=='DISALLOWED_SCRIPT_TAG'){return true;}const snippetChunks=html.split('\n');let snippet;if(!(snippet=html.split('\n')[event.line-1])||!(snippet=snippet.substring(event.col))){return true;}snippet=snippet+snippetChunks.slice(event.line).join('\n');snippet=snippet.substring(0,snippet.indexOf('</script>'));return!snippet.includes('data-amp-development-mode-only');}/**
   * Check if resolver function is build or request new build for this function
   * @param {string} pathname
   */async resolveApiRequest(pathname){try{await this.hotReloader.ensurePage(pathname);}catch(err){// API route dosn't exist => return 404
if(err.code==='ENOENT'){return null;}}const resolvedPath=await super.resolveApiRequest(pathname);return resolvedPath;}async renderToHTML(req,res,pathname,query,options={}){const compilationErr=await this.getCompilationError(pathname);if(compilationErr){res.statusCode=500;return this.renderErrorToHTML(compilationErr,req,res,pathname,query);}// In dev mode we use on demand entries to compile the page before rendering
try{await this.hotReloader.ensurePage(pathname).catch(async err=>{if(err.code!=='ENOENT'){throw err;}for(const dynamicRoute of this.dynamicRoutes){const params=dynamicRoute.match(pathname);if(!params){continue;}return this.hotReloader.ensurePage(dynamicRoute.page).then(()=>{pathname=dynamicRoute.page;query=Object.assign({},query,params);});}throw err;});}catch(err){if(err.code==='ENOENT'){res.statusCode=404;return this.renderErrorToHTML(null,req,res,pathname,query);}if(!this.quiet)console.error(err);}const html=await super.renderToHTML(req,res,pathname,query,options);return html;}async renderErrorToHTML(err,req,res,pathname,query){await this.hotReloader.ensurePage('/_error');const compilationErr=await this.getCompilationError(pathname);if(compilationErr){res.statusCode=500;return super.renderErrorToHTML(compilationErr,req,res,pathname,query);}if(!err&&res.statusCode===500){err=new Error('An undefined error was thrown sometime during render... '+'See https://err.sh/zeit/next.js/threw-undefined');}try{const out=await super.renderErrorToHTML(err,req,res,pathname,query);return out;}catch(err2){if(!this.quiet)Log.error(err2);res.statusCode=500;return super.renderErrorToHTML(err2,req,res,pathname,query);}}sendHTML(req,res,html){// In dev, we should not cache pages for any reason.
res.setHeader('Cache-Control','no-store, must-revalidate');return super.sendHTML(req,res,html);}setImmutableAssetCacheControl(res){res.setHeader('Cache-Control','no-store, must-revalidate');}servePublic(req,res,path){const p=(0,_path.join)(this.publicDir,path);return this.serveStatic(req,res,p);}async hasPublicFile(path){try{const info=await fsStat((0,_path.join)(this.publicDir,path));return info.isFile();}catch(_){return false;}}async getCompilationError(page){const errors=await this.hotReloader.getCompilationErrors(page);if(errors.length===0)return;// Return the very first error we found.
return errors[0];}}exports.default=DevServer;